const { ethers } = require("hardhat");

async function main() {
    console.log("üéØ Test du syst√®me d'ench√®res SANS ench√©risseur");
    console.log("=".repeat(55));

    // R√©cup√©rer les comptes de test
    const [owner, bidder1, bidder2] = await ethers.getSigners();

    console.log("üë• Comptes de test :");
    console.log("- Owner (cr√©ateur NFT):", owner.address);
    console.log("- Bidder 1:", bidder1.address);
    console.log("- Bidder 2:", bidder2.address);
    console.log();

    // R√©cup√©rer l'adresse du contrat d√©ploy√©
    const contractAddress = require("../src/contracts/contract-address.json");
    console.log("üìÑ Contrat NFTMarketplace √† l'adresse:", contractAddress.NFTMarketplace);

    // Connecter au contrat
    const NFTMarketplace = await ethers.getContractFactory("NFTMarketplace");
    const marketplace = NFTMarketplace.attach(contractAddress.NFTMarketplace);

    try {
        // 1. CR√âER UN NOUVEAU NFT
        console.log("üé® √âtape 1: Cr√©ation d'un nouveau NFT");
        console.log("-".repeat(35));

        const tokenURI = "data:application/json;base64," + Buffer.from(JSON.stringify({
            name: "Test No Bid NFT",
            description: "NFT de test pour ench√®re sans ench√©risseur",
            image: "https://via.placeholder.com/300x300.png?text=No+Bid+Test"
        })).toString('base64');

        const createTx = await marketplace.connect(owner).createToken(tokenURI, 0); // Prix 0 = pas en vente
        const createReceipt = await createTx.wait();

        // Extraire le tokenId depuis les events
        const transferEvent = createReceipt.events?.find(e => e.event === 'Transfer');
        const tokenId = transferEvent?.args?.tokenId?.toString();

        console.log("‚úÖ NFT cr√©√© avec l'ID:", tokenId);
        console.log("üìç Transaction:", createTx.hash);

        // V√©rifier le propri√©taire initial
        const initialOwner = await marketplace.ownerOf(tokenId);
        console.log("üè† Propri√©taire initial:", initialOwner);
        console.log("üë§ Owner address:", owner.address);
        console.log("‚úÖ Propri√©taire correct:", initialOwner === owner.address);
        console.log();

        // 2. LANCER UNE ENCH√àRE D'1 MINUTE
        console.log("‚è±Ô∏è  √âtape 2: Lancement d'une ench√®re d'1 minute (SANS ench√©risseur)");
        console.log("-".repeat(65));

        const startingPrice = ethers.utils.parseEther("0.2"); // 0.2 ETH
        const ONE_MINUTE = 0; // Enum AuctionDuration.ONE_MINUTE

        const auctionTx = await marketplace.connect(owner).startAuction(tokenId, startingPrice, ONE_MINUTE);
        const auctionReceipt = await auctionTx.wait();

        console.log("‚úÖ Ench√®re lanc√©e !");
        console.log("üí∞ Prix de d√©part:", ethers.utils.formatEther(startingPrice), "ETH");
        console.log("‚è∞ Dur√©e: 1 minute");
        console.log("üìç Transaction:", auctionTx.hash);
        console.log();

        // V√©rifier les d√©tails de l'ench√®re
        const auctionDetails = await marketplace.getAuction(tokenId);
        console.log("üìä D√©tails de l'ench√®re :");
        console.log("- ID Ench√®re:", auctionDetails.auctionId.toString());
        console.log("- Vendeur:", auctionDetails.seller);
        console.log("- Prix de d√©part:", ethers.utils.formatEther(auctionDetails.startingPrice), "ETH");
        console.log("- Ench√®re actuelle:", ethers.utils.formatEther(auctionDetails.highestBid), "ETH");
        console.log("- Ench√©risseur actuel:", auctionDetails.highestBidder);
        console.log("- Active:", auctionDetails.active);
        console.log("- Fin pr√©vue:", new Date(auctionDetails.endTime.toNumber() * 1000).toLocaleTimeString());
        console.log();

        // V√©rifier que le NFT est maintenant d√©tenu par le contrat
        const ownerDuringAuction = await marketplace.ownerOf(tokenId);
        console.log("üè† Propri√©taire pendant l'ench√®re:", ownerDuringAuction);
        console.log("üè¢ Adresse du contrat:", contractAddress.NFTMarketplace);
        console.log("‚úÖ NFT d√©tenu par le contrat:", ownerDuringAuction.toLowerCase() === contractAddress.NFTMarketplace.toLowerCase());
        console.log();

        // 3. V√âRIFIER QU'IL N'Y A PAS D'ENCH√âRISSEUR
        console.log("‚ùå √âtape 3: Confirmation qu'aucune ench√®re n'est plac√©e");
        console.log("-".repeat(50));

        const currentAuction = await marketplace.getAuction(tokenId);
        console.log("üí∞ Ench√®re actuelle:", ethers.utils.formatEther(currentAuction.highestBid), "ETH");
        console.log("üë§ Ench√©risseur actuel:", currentAuction.highestBidder);

        if (currentAuction.highestBid.eq(0) && currentAuction.highestBidder === ethers.constants.AddressZero) {
            console.log("‚úÖ Confirmation: Aucune ench√®re plac√©e");
        } else {
            console.log("‚ùå Erreur: Il y a d√©j√† des ench√®res !");
            return;
        }
        console.log();

        // 4. ATTENDRE LA FIN DE L'ENCH√àRE
        console.log("‚è≥ √âtape 4: Attente de la fin de l'ench√®re (1 minute)...");
        console.log("-".repeat(55));

        const currentTime = Math.floor(Date.now() / 1000);
        const endTime = currentAuction.endTime.toNumber();
        const remainingTime = endTime - currentTime;

        if (remainingTime > 0) {
            console.log("‚è∞ Temps restant:", remainingTime, "secondes");
            console.log("üí§ Attente sans aucune ench√®re...");

            // Attendre que l'ench√®re se termine
            await new Promise(resolve => setTimeout(resolve, (remainingTime + 2) * 1000));
        }

        console.log("‚úÖ Ench√®re termin√©e !");
        console.log();

        // 5. V√âRIFIER QUE L'ENCH√àRE EST TERMIN√âE
        console.log("üîç √âtape 5: V√©rification de l'√©tat de l'ench√®re");
        console.log("-".repeat(45));

        const isEnded = await marketplace.isAuctionEnded(tokenId);
        console.log("‚è∞ Ench√®re termin√©e (temps √©coul√©):", isEnded);

        const auctionState = await marketplace.getAuction(tokenId);
        console.log("üìä √âtat actuel :");
        console.log("- Active:", auctionState.active);
        console.log("- Termin√©e:", auctionState.ended);
        console.log("- Ench√®re finale:", ethers.utils.formatEther(auctionState.highestBid), "ETH");
        console.log("- Ench√©risseur final:", auctionState.highestBidder);
        console.log();

        // 6. TERMINER L'ENCH√àRE
        console.log("üèÅ √âtape 6: Finalisation de l'ench√®re sans ench√©risseur");
        console.log("-".repeat(55));

        const endTx = await marketplace.connect(owner).endAuction(tokenId);
        const endReceipt = await endTx.wait();
        console.log("‚úÖ Ench√®re finalis√©e !");
        console.log("üìç Transaction:", endTx.hash);

        // V√©rifier les √©v√©nements
        const auctionEndedEvent = endReceipt.events?.find(e => e.event === 'AuctionEnded');
        if (auctionEndedEvent) {
            console.log("üéâ Gagnant:", auctionEndedEvent.args.winner);
            console.log("üí∞ Prix final:", ethers.utils.formatEther(auctionEndedEvent.args.winningBid), "ETH");

            if (auctionEndedEvent.args.winner === ethers.constants.AddressZero) {
                console.log("‚úÖ Confirmation: Aucun gagnant (comme attendu)");
            } else {
                console.log("‚ùå Erreur: Il y a un gagnant alors qu'il ne devrait pas y en avoir");
            }
        }
        console.log();

        // 7. V√âRIFIER QUE LE NFT EST RETOURN√â AU PROPRI√âTAIRE ORIGINAL
        console.log("üîÑ √âtape 7: V√©rification du retour du NFT au propri√©taire");
        console.log("-".repeat(55));

        const finalOwner = await marketplace.ownerOf(tokenId);
        console.log("üè† Propri√©taire final du NFT:", finalOwner);
        console.log("üë§ Propri√©taire original:", owner.address);

        if (finalOwner.toLowerCase() === owner.address.toLowerCase()) {
            console.log("‚úÖ TEST R√âUSSI: Le NFT est retourn√© au propri√©taire original !");
        } else {
            console.log("‚ùå TEST √âCHOU√â: Le NFT n'est pas retourn√© au bon propri√©taire");
            console.log("   Attendu:", owner.address);
            console.log("   Re√ßu:", finalOwner);
        }
        console.log();

        // 8. V√âRIFIER L'√âTAT FINAL DE L'ENCH√àRE
        console.log("üìä √âtape 8: V√©rification de l'√©tat final de l'ench√®re");
        console.log("-".repeat(50));

        const finalAuctionState = await marketplace.getAuction(tokenId);
        console.log("üìã √âtat final de l'ench√®re :");
        console.log("- Active:", finalAuctionState.active);
        console.log("- Termin√©e:", finalAuctionState.ended);
        console.log("- Ench√®re finale:", ethers.utils.formatEther(finalAuctionState.highestBid), "ETH");
        console.log("- Ench√©risseur final:", finalAuctionState.highestBidder);

        if (!finalAuctionState.active && finalAuctionState.ended) {
            console.log("‚úÖ √âtat correct: Ench√®re inactive et marqu√©e comme termin√©e");
        } else {
            console.log("‚ùå √âtat incorrect de l'ench√®re");
        }
        console.log();

        // 9. V√âRIFIER L'√âTAT DU MARKET ITEM
        console.log("üè™ √âtape 9: V√©rification de l'√©tat du MarketItem");
        console.log("-".repeat(45));

        const marketItem = await marketplace.getMarketItem(tokenId);
        console.log("üõçÔ∏è MarketItem final :");
        console.log("- Propri√©taire:", marketItem.owner);
        console.log("- Vendeur:", marketItem.seller);
        console.log("- Prix:", ethers.utils.formatEther(marketItem.price), "ETH");
        console.log("- Vendu:", marketItem.sold);
        console.log("- List√©:", marketItem.listed);
        console.log("- En ench√®re:", marketItem.inAuction);

        if (!marketItem.inAuction && marketItem.owner.toLowerCase() === owner.address.toLowerCase()) {
            console.log("‚úÖ MarketItem correct: Plus en ench√®re, retourn√© au propri√©taire");
        } else {
            console.log("‚ùå MarketItem incorrect");
        }
        console.log();

        // R√âSUM√â FINAL
        console.log("üéâ R√âSUM√â DES TESTS SANS ENCH√âRISSEUR");
        console.log("=".repeat(55));
        console.log("‚úÖ NFT cr√©√© avec succ√®s");
        console.log("‚úÖ Ench√®re d'1 minute lanc√©e");
        console.log("‚úÖ Aucune ench√®re plac√©e (comme voulu)");
        console.log("‚úÖ Ench√®re termin√©e automatiquement");
        console.log("‚úÖ NFT retourn√© au propri√©taire original");
        console.log("‚úÖ √âtat de l'ench√®re correctement mis √† jour");
        console.log("‚úÖ MarketItem remis dans l'√©tat initial");
        console.log();
        console.log("üéØ TEST SANS ENCH√âRISSEUR R√âUSSI !");
        console.log("üí° Le NFT revient bien au propri√©taire quand personne n'ench√©rit");

    } catch (error) {
        console.error("‚ùå Erreur lors des tests:", error);
        console.error("Stack:", error.stack);
        process.exit(1);
    }
}

main()
    .then(() => process.exit(0))
    .catch((error) => {
        console.error("‚ùå Erreur fatale:", error);
        process.exit(1);
    });